[{"content":" 专辑名称: CHROMAKOPIA 歌手: Tyler, The Creator 发行时间: 2024-10-28 发行公司: 索尼音乐 ","permalink":"https://garywy.github.io/zh/music/2024-11-08/","summary":"专辑名称: CHROMAKOPIA 歌手: Tyler, The Creator 发行时间: 2024-10-28 发行公司: 索尼音乐","title":"CHROMAKOPIA"},{"content":" 专辑名称: Angel Face 歌手: Stephen Sanchez 发行时间: 2023-09-22 发行公司: Mercury Records / Republic Records ","permalink":"https://garywy.github.io/zh/music/2024-10-10/","summary":"专辑名称: Angel Face 歌手: Stephen Sanchez 发行时间: 2023-09-22 发行公司: Mercury Records / Republic Records","title":"Angel Face"},{"content":" 专辑名称: Madvillainy 歌手: Madvillain / MF DOOM / Madlib 发行时间: 2004-03-24 发行公司: Stones Throw Records ","permalink":"https://garywy.github.io/zh/music/2024-10-07/","summary":"专辑名称: Madvillainy 歌手: Madvillain / MF DOOM / Madlib 发行时间: 2004-03-24 发行公司: Stones Throw Records","title":"Madvillainy"},{"content":" 专辑名称: Melophobia 歌手: Cage the Elephant 发行时间: 2013-10-08 发行公司: 索尼音乐 ","permalink":"https://garywy.github.io/zh/music/2024-10-04/","summary":"专辑名称: Melophobia 歌手: Cage the Elephant 发行时间: 2013-10-08 发行公司: 索尼音乐","title":"Melophobia"},{"content":" 专辑名称: Silence Between Songs 歌手: Madison Beer 发行时间: 2023-09-15 发行公司: 索尼音乐 ","permalink":"https://garywy.github.io/zh/music/2024-10-02/","summary":"专辑名称: Silence Between Songs 歌手: Madison Beer 发行时间: 2023-09-15 发行公司: 索尼音乐","title":"Silence Between Songs"},{"content":" 专辑名称: NEVER ENOUGH 歌手: Daniel Caesar 发行时间: 2023-04-07 发行公司: Republic Records ","permalink":"https://garywy.github.io/zh/music/2024-10-01/","summary":"专辑名称: NEVER ENOUGH 歌手: Daniel Caesar 发行时间: 2023-04-07 发行公司: Republic Records","title":"NEVER ENOUGH"},{"content":" 专辑名称: In the Aeroplane Over the Sea 歌手: Neutral Milk Hotel 发行时间: 1998-02-20 发行公司: Merge Records ","permalink":"https://garywy.github.io/zh/music/2024-09-30/","summary":"专辑名称: In the Aeroplane Over the Sea 歌手: Neutral Milk Hotel 发行时间: 1998-02-20 发行公司: Merge Records","title":"In the Aeroplane Over the Sea"},{"content":"前言 因为总是在动态规划问题上碰壁，所以想总结一下动态规划问题的解决办法。\nDP问题基本解题思路：\n初始状态 状态转移方程 1. 线性DP 1.1 例题：Leetcode 300. Longest Increasing Subsequence Given an integer array nums, return the length of the longest strictly increasing subsequence.\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\nExample 3:\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n(1) 思路\n初始状态 本题dp[n]可以是前n个元素中的最长子序列的长度。所以dp[0]可以是说只有一个元素的时候，那最长子序列的长度就是1。 dp[0] = 1 状态转移方程 如果有两个元素的时候，需要判断第一个元素和第二个元素之间的大小关系。 nums=[1, 3]，那么此时dp[1] = dp[0] + 1。 nums=[3, 1]，那么此时dp[1] = dp[0] 如果有三个元素的时候，在已知dp[0]和dp[1]的情况下，需要判断第三个元素和之前所有元素的大小关系。 nums=[1, 3, x]，首先1和x比大小，如果1\u0026lt;x的情况下，dp[2] = dp[0] + 1, 以此类推3和x比大小，如果3\u0026lt;x的情况下，dp[2] = dp[1] + 1。 此后的流程以此类推。 dp[i]指的是第i个元素前最长子序列长度，所以最终结果就是max(dp)。 (2) Python代码\ndef longest_increasing_subsequence(nums: list): res = 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j]+1) return max(dp) nums = [10,9,2,5,3,7,101,18] print(longest_increasing_subsequence(nums)) 1.2 例题：Leetcode 32. Longest Valid Parentheses\nGiven a string containing just the characters \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo;, return the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: s = \u0026ldquo;(()\u0026rdquo;\nOutput: 2\nExplanation: The longest valid parentheses substring is \u0026ldquo;()\u0026rdquo;.\nExample 2:\nInput: s = \u0026ldquo;)()())\u0026rdquo;\nOutput: 4\nExplanation: The longest valid parentheses substring is \u0026ldquo;()()\u0026rdquo;.\nExample 3:\nInput: s = \u0026quot;\u0026quot;\nOutput: 0\n(1) 思路\n初始状态 本题dp可以是前n个元素中的完整括号的个数。dp[0]就是只有一个元素，那么肯定不是完整括号，所以完整括号的个数为0。 dp[0] = 0 状态转移方程 如果当元素s[i]==\u0026quot;)\u0026quot;的时候，那么就需要判断前一个元素s[i-1]==\u0026quot;(\u0026quot;?。 如果s[i-1]==\u0026quot;(\u0026quot;的时候，如果i\u0026gt;=2的时候， dp[i] = dp[i-2] + 2；否则dp[i] = 2。 如果s[i-1]==\u0026quot;)\u0026quot;的时候，那个就需要去找在该元素之前的)，也就是s[i-1-dp[i-1]]。所以上述的状态转移方程需要改变。如果i\u0026gt;=2的时候， dp[i] = dp[i-1] + dp[i-2-dp[i-1]] + 2；否则dp[i] = dp[i-1] + 2。 (2) Python代码\ndef longest_valid_parentheses(s: str): dp = [0]*(len(s)+1) for i in range(1, len(s)): if s[i] == \u0026#34;)\u0026#34;: if s[i-1] == \u0026#34;(\u0026#34;: if i \u0026gt;= 2: dp[i] = dp[i-2] + 2 else: dp[i] = 2 elif s[i-1-dp[i-1]] == \u0026#34;(\u0026#34; and i \u0026gt; dp[i-1]: if i \u0026gt;= 2: dp[i] = dp[i-1] + dp[i-2-dp[i-1]] + 2 else: dp[i] = dp[i-1] + 2 return max(dp) s = \u0026#34;(()\u0026#34; print(longest_valid_parentheses(s)) 1.3 例题 Leetcode 97. Interleaving String\nGiven strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\ns = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| \u0026lt;= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ...or t1 + s1 + t2 + s2 + t3 + s3 + ...\nNote: a + b is the concatenation of strings a and b. Example 1:\nInput: s1 = \u0026ldquo;aabcc\u0026rdquo;, s2 = \u0026ldquo;dbbca\u0026rdquo;, s3 = \u0026ldquo;aadbbcbcac\u0026rdquo;\nOutput: true\nExplanation:\nOne way to obtain s3 is:\nSplit s1 into s1 = \u0026ldquo;aa\u0026rdquo; + \u0026ldquo;bc\u0026rdquo; + \u0026ldquo;c\u0026rdquo;, and s2 into s2 = \u0026ldquo;dbbc\u0026rdquo; + \u0026ldquo;a\u0026rdquo;.\nInterleaving the two splits, we get \u0026ldquo;aa\u0026rdquo; + \u0026ldquo;dbbc\u0026rdquo; + \u0026ldquo;bc\u0026rdquo; + \u0026ldquo;a\u0026rdquo; + \u0026ldquo;c\u0026rdquo; = \u0026ldquo;aadbbcbcac\u0026rdquo;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\nExample 2:\nInput: s1 = \u0026ldquo;aabcc\u0026rdquo;, s2 = \u0026ldquo;dbbca\u0026rdquo;, s3 = \u0026ldquo;aadbbbaccc\u0026rdquo;\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\nExample 3:\nInput: s1 = \u0026ldquo;\u0026rdquo;, s2 = \u0026ldquo;\u0026rdquo;, s3 = \u0026quot;\u0026quot;\nOutput: true\n(1) 思路\n初始状态 本题dp是指s1的前i个元素和s2的前j个元素符合上述规则，即可以组合成为s3。 dp[0][0] = True 状态转移方程 首先考虑边界条件，即判断dp[i][0]和dp[0][j]。该情况是指s1前i个元素是否为s3的前i个元素或者s2前j个元素是否为s3的前j个元素。 dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] (i\u0026gt;=1) dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] (j\u0026gt;=1) 其次考虑dp[i][j]的情况。有两个可能性，一种是s1的第i个元素是否等于s3的第i+j个元素，另一种是s2的第j个元素是否等于s3的第i+j个元素。即有以下任何一种情况都成立。 dp[i][j] = dp[i-1][j] and s1[i-1] == s3[i+j-1] (i,j\u0026gt;=1) dp[i][j] = dp[i][j-1] and s2[j-1] == s3[i+j-1] (i,j\u0026gt;=1) 注意第n个元素的下标为n-1。 (2) Python代码\ndef interleaving_string(s1: str, s2: str, s3: str): m, n = len(s1), len(s2) if m+n != len(s3): return False dp = [[False]*(n+1) for _ in range(m+1)] dp[0][0] = True for i in range(1, m+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in range(1, n+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in range(1, m+1): for j in range(1, n+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or \\ (dp[i][j-1] and s2[j-1] == s3[i+j-1]) return dp[-1][-1] s1 = \u0026#34;aabcc\u0026#34; s2 = \u0026#34;dbbca\u0026#34; s3 = \u0026#34;aadbbcbcac\u0026#34; print(interleaving_string(s1, s2, s3)) 1.4 例题 Leetcode 115. Distinct Subsequences\nGiven two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer.\nExample 1:\nInput: s = \u0026ldquo;rabbbit\u0026rdquo;, t = \u0026ldquo;rabbit\u0026rdquo;\nOutput: 3 Explanation:\nAs shown below, there are 3 ways you can generate \u0026ldquo;rabbit\u0026rdquo; from s. rabbbit\nrabbbit\nrabbbit\nExample 2:\nInput: s = \u0026ldquo;babgbag\u0026rdquo;, t = \u0026ldquo;bag\u0026rdquo; Output: 5\nExplanation:\nAs shown below, there are 5 ways you can generate \u0026ldquo;bag\u0026rdquo; from s.\nbabgbag\nbabgbag\nbabgbag\nbabgbag babgbag\n(1) 思路\n初始状态 本题dp是指t的前i个元素在s的前j个元素中存在子序列的个数。 dp[0][j] = 1，即t中的前0个元素（“”）在s中一定存在一个子序列。 状态转移方程 参考例题1.3，我们可以先穷举。 dp[1][0] = 0, dp[2][0] = 0, ... dp[1][1] = dp[0][0] + dp[0][1] if t[0] == s[0] else dp[0][1] dp[1][2] = dp[0][1] + dp[1][1] if t[0] == s[1] else dp[1][1] dp[2][1] = dp[1][0] + dp[2][0] if t[1] == s[0] else dp[2][0] 综上可得 dp[i][j] = dp[i-1][j-1] + dp[i][j-1] if t[i-1] == s[j-1] else dp[i][j-1] (i,j\u0026gt;=1) (2) Python代码\ndef distinct_subsequences(s: str, t: str): dp = [[0]*(len(s)+1) for _ in range(len(t)+1)] for j in range(len(s)+1): dp[0][j] = 1 for i in range(1, len(t)+1): for j in range(1, len(s)+1): dp[i][j] = dp[i-1][j-1] + dp[i][j-1] if t[i-1] == s[j-1] \\ else dp[i][j-1] return dp[-1][-1] s = \u0026#34;rabbbit\u0026#34; t = \u0026#34;rabbit\u0026#34; print(distinct_subsequences(s, t)) 1.5 例题 Leetcode 53. Maximum Subarray\nGiven an integer array nums, find the subarray with the largest sum, and return its sum.\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nExample 2:\nInput: nums = [1] Output: 1\nExplanation: The subarray [1] has the largest sum 1.\nExample 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n(1) 思路\n初始状态 本题dp可以指前i个元素中最大的和。 dp[0] = -inf 状态转移方程 dp[i] = max(nums[i-1], nums[i-1]+dp[i-1]) (2) Python代码\ndef maximum_subarray(nums: list): dp = [float(\u0026#34;-inf\u0026#34;) for _ in range(len(nums)+1)] for i in range(1, len(nums)+1): dp[i] = max(nums[i-1], nums[i-1]+dp[i-1]) return max(dp) nums = [-2,1,-3,4,-1,2,1,-5,4] print(maximum_subarray(nums)) 1.6 例题 Leetcode 152. Maximum Product Subarray\nGiven an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.\nExample 1:\nInput: nums = [2,3,-2,4]\nOutput: 6 Explanation: [2,3] has the largest product 6.\nExample 2:\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n(1) 思路\n初始状态 本题思路与例题1.5几乎一致，但是在乘法中，存在负数相乘的情况，所以需要同时保存最大值和最小值。因此需要设置dp_max和dp_min。 dp_max[0] = 0, dp_min[0] = 0 状态转移方程 dp_max[i] = max(nums[i-1], nums[i-1]*dp_max[i-1], nums[i-1]*dp_min[i-1]) dp_min[i] = min(nums[i-1], nums[i-1]*dp_max[i-1], nums[i-1]*dp_min[i-1]) (2) Python代码\ndef maximum_product_subarray(nums: list): if len(nums) == 1: return nums[0] dp_max = [0 for _ in range(len(nums)+1)] dp_min = [0 for _ in range(len(nums)+1)] for i in range(1, len(nums)+1): dp_max[i] = max(nums[i-1], nums[i-1]*dp_max[i-1], nums[i-1]*dp_min[i-1]) dp_min[i] = min(nums[i-1], nums[i-1]*dp_max[i-1], nums[i-1]*dp_min[i-1]) return max(dp_max) nums = [2,3,-2,4] print(maximum_product_subarray(nums)) 1.7 例题 Leetcode 198. House Robber\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n(1) 思路\n初始状态 首先确定dp的含义，本题可以是前i家房屋中金钱的最大值。因此为一维，并可确定初始状态。 dp[0] = 0, dp[1] = nums[0] 状态转移方程\n题目要求不能连续偷相邻房屋，例如在偷第3家的时候，我们必须确保前一天偷的是第1家。那么dp[3]事实上就是第1家和第3家的金钱总和和第2家金钱中的最大值，以此类推转移方程如下。 dp[i] = max(dp[i-2]+nums[i-1], dp[i-1]) (i\u0026gt;=2) (2) Python代码\ndef house_robber(nums: list): dp = [0 for _ in range(len(nums)+1)] dp[0], dp[1] = 0, nums[0] for i in range(2, len(nums)+1): dp[i] = max(dp[i-2]+nums[i-1], dp[i-1]) return dp[-1] nums = [1,2,3,1] print(house_robber(nums)) 1.8 例题 Leetcode 213. House Robber II\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\n(1) 思路\n初始状态 首先确定dp的含义，本题可以是前i家房屋中金钱的最大值。因此为一维，并可确定初始状态。 dp[0] = 0, dp[1] = nums[0] 状态转移方程\n题目要求不能连续偷相邻房屋，例如在偷第3家的时候，我们必须确保前一天偷的是第1家。那么dp[3]事实上就是第1家和第3家的金钱总和和第2家金钱中的最大值，以此类推转移方程如下。 dp[i] = max(dp[i-2]+nums[i-1], dp[i-1]) (i\u0026gt;=2) 以上均与例题1.8完全一致，但是首尾的房屋为连续排列。此时我们可以分为两个部分进行计算，若存在n个房屋，我们可以先计算前n-1个房屋，再计算后n-1个房屋，以此确保首尾不会连续，然后取其中的最大值。 (2) Python代码\ndef house_robber(nums: list): dp = [0 for _ in range(len(nums)+1)] dp[0], dp[1] = 0, nums[0] for i in range(2, len(nums)+1): dp[i] = max(dp[i-2]+nums[i-1], dp[i-1]) return dp[-1] def house_robber2(nums: list): return max(house_robber(nums[1:]), house_robber(nums[:-1])) nums = [2,3,2] print(house_robber2(nums)) 1.9 例题 Leetcode 72. Edit Distance\nGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nInsert a character Delete a character Replace a character Example 1:\nInput: word1 = \u0026ldquo;horse\u0026rdquo;, word2 = \u0026ldquo;ros\u0026rdquo;\nOutput: 3\nExplanation: horse -\u0026gt; rorse (replace \u0026lsquo;h\u0026rsquo; with \u0026lsquo;r\u0026rsquo;) rorse -\u0026gt; rose (remove \u0026lsquo;r\u0026rsquo;)\nrose -\u0026gt; ros (remove \u0026rsquo;e\u0026rsquo;)\nExample 2:\nInput: word1 = \u0026ldquo;intention\u0026rdquo;, word2 = \u0026ldquo;execution\u0026rdquo;\nOutput: 5\nExplanation:\nintention -\u0026gt; inention (remove \u0026rsquo;t\u0026rsquo;)\ninention -\u0026gt; enention (replace \u0026lsquo;i\u0026rsquo; with \u0026rsquo;e\u0026rsquo;)\nenention -\u0026gt; exention (replace \u0026rsquo;n\u0026rsquo; with \u0026lsquo;x\u0026rsquo;)\nexention -\u0026gt; exection (replace \u0026rsquo;n\u0026rsquo; with \u0026lsquo;c\u0026rsquo;)\nexection -\u0026gt; execution (insert \u0026lsquo;u\u0026rsquo;)\n(1) 思路\n初始状态 首先确定dp的含义，本题可以是word1的前i个元素和word2的前j个元素之间的编辑距离。因此为二维，并可确定初始状态。 dp[0][0] = 0, dp[i][0] = i, dp[0][j] = j 状态转移方程 该题目的简单来说就是找到插入代价，消除代价以及置换代价中的最小值。插入一个元素或消除一个元素，其都需要操作一次，即插入代价和消除代价为1。如果当word1中的第i个元素和word2中的第j个元素相等的时候，此时不需要置换，否则需要操作一次，即置换代价为1或0. insert_cost = 1, delete_cost = 1 replace_cost = 0 if word1[i-1] == word2[j-1] else 1 dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1] + replace_cost) (i,j\u0026gt;=1) (2) Python代码\ndef edit_distance(word1: str, word2: str): dp = [[0]*(len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): replace_cost = 0 if word1[i-1] == word2[j-1] else 1 dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+replace_cost) return dp[-1][-1] word1 = \u0026#34;horse\u0026#34; word2 = \u0026#34;ros\u0026#34; print(edit_distance(word1, word2)) 1.10 例题 Leetcode 44. Wildcard Matching\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n'?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).\nExample 1:\nInput: s = \u0026ldquo;aa\u0026rdquo;, p = \u0026ldquo;a\u0026rdquo;\nOutput: false\nExplanation: \u0026ldquo;a\u0026rdquo; does not match the entire string \u0026ldquo;aa\u0026rdquo;.\nExample 2:\nInput: s = \u0026ldquo;aa\u0026rdquo;, p = \u0026ldquo;*\u0026rdquo; Output: true\nExplanation: \u0026lsquo;*\u0026rsquo; matches any sequence.\nExample 3:\nInput: s = \u0026ldquo;cb\u0026rdquo;, p = \u0026ldquo;?a\u0026rdquo; Output: false\nExplanation: \u0026lsquo;?\u0026rsquo; matches \u0026lsquo;c\u0026rsquo;, but the second letter is \u0026lsquo;a\u0026rsquo;, which does not match \u0026lsquo;b\u0026rsquo;.\n(1) 思路\n初始状态 首先确定dp的含义，本题是s的前i个元素和p的前j个元素之间是否匹配。因此为二维，并可确定初始状态。 dp[0][0] = True\n由于只有*可以匹配空字符，所以需要判断第j个元素是否为*. dp[0][j] = dp[0][j-1] if p[j-1] == \u0026quot;*\u0026quot; 状态转移方程 如果p中第j个元素为*时，那么任意匹配，即dp[i][j] = dp[i-1][j] or dp[i][j-1]， 表示是否使用该*.\n如果p中第j个元素为?或p中第j个元素为*与s的第i个元素相等时，那么dp[i][j] = dp[i-1][j-1]. (2) Python代码\ndef wildcard_matching(s: str, p: str): dp = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[0][0] = True for j in range(1, len(p)+1): if p[j-1] == \u0026#34;*\u0026#34;: dp[0][j] = dp[0][j-1] for i in range(1, len(s)+1): for j in range(1, len(p)+1): if p[j-1] == \u0026#34;*\u0026#34;: dp[i][j] = dp[i-1][j] or dp[i][j-1] if p[j-1] == \u0026#34;?\u0026#34; or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] return dp[-1][-1] s = \u0026#34;cb\u0026#34; p = \u0026#34;?a\u0026#34; print(wildcard_matching(s, p)) 3. 背包DP 2.1 例题 Leetcode 377. Combaination Sum IV\nGiven an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\nThe test cases are generated so that the answer can fit in a 32-bit integer.\nExample 1:\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are: (1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1).\nNote that different sequences are counted as different combinations.\nExample 2:\nInput: nums = [9], target = 3\nOutput: 0\n(1) 思路\n初始状态 首先确定dp的含义，本题的dp[i]是指当target是i的时候，有多少种组合。当target=0的时候，只有一种组合那就是什么都不取，即： dp[0] = 1 状态转移方程 当target=i的时候，即dp[i]，我们需要对nums中每一个元素（num）进行判断。如果当num\u0026lt;=i的时候，那就意味着存在这种组合，那么剩下的就是取出当target=i-num的组合数，即dp[i-num]。由此可得，转移方程为： dp[i] += dp[i-num] if num \u0026lt;= i (2) Python代码\ndef combaination_sum(nums: list, target: int): dp = [0] * (target+1) dp[0] = 1 for i in range(1, target+1): for num in nums: if num \u0026lt;= i: dp[i] += dp[i-num] return dp[-1] nums = [1,2,3] target = 4 print(combaination_sum(nums, target)) 4. 递推型DP 4.1 例题 Leetcode 70. Climbing Stairs\nYou are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1 step + 1 step 2 steps Example 2:\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step (1) 思路\n初始状态 首先确定dp的含义，本题的dp[i]是指在到达第i层有多少种方法。当i=0或i=1的时候，只有一种组合那就是不走或走1步，即： dp[0] = 1, dp[1] = 1 状态转移方程 由题意可得，当我们想要到达第i层的时候，只有两种办法，一种是走了1步，另一种是走了2步。那么得知，想求dp[i]，可以求走i步到达i层(dp[i-1])和走2步到达i层(dp[i-2])的总数。由此可得，转移方程为： dp[i] = dp[i-1] + dp[i-2] (i\u0026gt;=2) (2) Python代码\ndef climbing_stairs(n: int): dp = [0] * (n+1) dp[0], dp[1] = 1, 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[-1] n = 3 print(climbing_stairs(n)) ","permalink":"https://garywy.github.io/zh/posts/study/dp_question/","summary":"前言 因为总是在动态规划问题上碰壁，所以想总结一下动态规划问题的解决办法。 DP问题基本解题思路： 初始状态 状态转移方程 1. 线性DP 1.1 例题：Leet","title":"DP_Question"},{"content":" 专辑名称: Room On Fire 歌手: The Strokes 发行时间: 2003-10-28 发行公司: 索尼音乐 ","permalink":"https://garywy.github.io/zh/music/2024-09-29/","summary":"专辑名称: Room On Fire 歌手: The Strokes 发行时间: 2003-10-28 发行公司: 索尼音乐","title":"Room On Fire"},{"content":" 专辑名称: Random Access Memories 歌手: Daft Punk 发行时间: 2013-05-17 发行公司: 索尼音乐 ","permalink":"https://garywy.github.io/zh/music/2024-09-28/","summary":"专辑名称: Random Access Memories 歌手: Daft Punk 发行时间: 2013-05-17 发行公司: 索尼音乐","title":"Random Access Memories"},{"content":"前言 本文主要为总结Markdown常用语法，以便于自已能够更好的书写Markdown文件。\n1. 基本语法 1.1 标题 利用#符号创建标题，有几个#就是几级标题。\nMarkdown 效果 # 标题1 标题1 # 标题2 标题1 # 标题3 标题1 1.2 换行 在文本后添加2个及以上空格，或添加一个空白行（按两次回车）。\n1.3 强调 粗体\n**text**或__text__ 斜体\n*text*或_text_ 斜体加粗体\n***text***或___text___ _和*可以相互替换。 1.4 引用 单段引用\n\u0026gt; Hello World! Hello World!\n多段引用 \u0026gt; Hello \u0026gt; \u0026gt; World! Hello\nWorld!\n嵌套块引用 \u0026gt; Hello \u0026gt; \u0026gt;\u0026gt; World! Hello\nWorld!\n带有其他元素的引用 \u0026gt; _Hello_ \u0026gt; \u0026gt;\u0026gt; **World**! Hello\nWorld!\n1.5 列表 有序列表 1. First 2. Second 1. S1 2. S2 3. Third First Second S1 S2 Third 无序列表\n+,-和*可相互替换。 - First - Second + S1 + S2 - Third First Second S1 S2 Third 1.6 代码块 围栏代码（可定义代码类型且显示代码高亮）,可以用```或~~~\n```python print(Hello World!) ``` print(Hello World!) 对文本使用代码块可以使用`或 `` 。\nHello World 1.7 分割线 ---,***和___均可以表示分割线。\n--- *** ___ 1.8 链接 有标题的链接 这是一个[链接](https://www.google.com/) 这是一个链接 网址 \u0026lt;https://www.google.com/\u0026gt; https://www.google.com/ 1.9 图片 显示图片 ![title](../img/display.jpeg) 给图片增加链接 [![title](../img/display.jpeg)](https://www.google.com/) 1.10 转义字符 转义字符为\\。\n\\# title # title\n","permalink":"https://garywy.github.io/zh/posts/study/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"前言 本文主要为总结Markdown常用语法，以便于自已能够更好的书写Markdown文件。 1. 基本语法 1.1 标题 利用#符号创建标题，有几个#就是几","title":"Markdown学习笔记"},{"content":"1. 前言 原本是因为学习任务要求需要做一个Web Service，结果阴差阳错的发现了hugo这个工具。所以借此机会利用hugo制作了自己的个人博客。此篇文章内容主要包括了搭建个人网站的流程，我在其中遇到的一些问题以及解决方案，希望能对你有帮助。\n由于博主使用的是mac os，所以与windows系统可能有所差别。\n2. hugo 2.1 hugo的安装 首先利用terminal安装hugo。\nbrew install hugo 如果没有brew的同学，需要提前安装homebrew（mac os）。\n2.2 利用hugo建立博客 首先利用以下命令建立hugo博客。\nhugo new site foldername foldername填写任意你喜欢的名字，注意以后的所有操作均需要在该目录下进行。 创建成功后进入该目录，可以发现有9个文件。\narchetypes 该文件夹只有一个default.md文件，该文件内部只包含了文件头，主要的作用是每次创建新的md文件时，会按照该文件内设置的默认格式进行创建。 +++ title = \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; #创建时的文件名称 date = {{ .Date }} #当前日期和时间 draft = true #是否为草稿 +++ 以下代码是在hugo中创建新md文件的方法，其中的blog为自定义，创建成功后上述代码中的title部分就会变成blog。\nhugo new blog.md content 该文件夹内部为空，需要用户自己进行添加。例如你希望你的博客里有一个关于学习的板块，那你就可以在这个目录下创建一个叫学习的文件夹。 hugo.toml 该文件是hogo的配置文件，非常重要。由于toml语法较为麻烦，且查询到的资料大都是将toml文件改成了yaml文件，所以推荐使用yaml格式的配置文件。后续会详细说明。 layouts 该文件夹在未添加主题之前为空，添加主题之后大多是html文件，用于展示各个页面。 themes 该文件夹在下载主题之后，会被保存在该目录下，不用做任何改变。 assets 用于存放css文件。 data 没用过，不太清楚是什么作用。 i18n 也没用过。 static 该文件主要可以用来储存图片。 以上是关于相关文件的介绍，没有必要很仔细的记住，后面需要的话可以返回来看一看。\n下来设置主题，需要进入Hugo Themes选择喜欢的主题。 我选择的主题是该网站的第一个主题PaperMod，需要注意的是每个主题的配置文件都不太一样，具体内容需要查看该主题相关的文档。 点击喜欢的主题之后会出现download的字样，点击download即可进入GitHub界面。 复制GitHub地址，并在终端输入以下代码。\ngit clone theme_address 将theme_address替换成你复制的GitHub地址 下载成功后会在你的根目录下找到名为该主题的文件夹，例如PaperMod下载成功后，会出现一个名为hugo-PaperMod的文件夹，将该文件夹整体移动到themes文件夹中。此后themes文件夹不需要再进行任何操作。然后在你的配置文件，也就是hugo.toml文件中添加以下内容。\ntheme = \u0026#39;theme_name\u0026#39; #theme = \u0026#39;hugo-PaperMod\u0026#39; 以上为toml文件的写法，yaml语法为以下内容。\ntheme: theme_name #theme: hugo-PaperMod 如果使用PaperMod主题，建议参照hugo博客搭建 | PaperMod主题进行配置文件的设置。 包括在content文件夹内进行的相关操作，也可以参照上述链接，讲述的非常清楚。\n2.3 hugo的启动 hugo有两种启动方式。\nhugo server hugo server -D 上述两种命令均可以启动博客，在启动成功后复制提示的网址，便可以本地进入博客。 两种命令的区别在于是否显示头文件中draft: true的md文件。 hugo server无法显示draft字段为true的文件，这点需要注意，所以可以在默认文件中将该字段改为false，这样所有新创建的md文件都会以非草稿的方式显示。\n按顺序完成上述内容便可以利用hugo完成属于自己的静态博客。 除上述链接之外还可以参照该博客内容Hugo + PaperMod搭建技术博客。\n2.4 hugo配置时遇到的问题 2.4.1 多语言 在配置文件hugo.yaml中，可以配置多种语言，例如我的配置文件中有中英双语。\nlanguages: en: languageName: \u0026#34;English\u0026#34; contentDir: content/English weight: 1 profileMode: enabled: true title: Gary\u0026#39;s House subtitle: \u0026#34;It\u0026#39;s happy to see you!\u0026#34; imageUrl: \u0026#34;img/me.jpg\u0026#34; #图片放在static/img/me.gif imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 🧑‍💻Tech url: posts/tech ... zh: languageName: \u0026#34;中文\u0026#34; contentDir: content/Chinese weight: 1 profileMode: enabled: true title: Gary\u0026#39;s House subtitle: \u0026#34;很高兴见到你！\u0026#34; imageUrl: \u0026#34;img/me.jpg\u0026#34; #图片放在static/img/me.gif imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 🧑‍💻技术 url: posts/tech/ ... 如果你参考了前文提到的链接中的配置文件的话，将其en后的部分复制粘贴一次，像上述所示。 为了做到多语言，需要在content文件夹下创建多个文件夹用来存放内容。如何我在content文件夹中就创建了English和Chinese两个文件夹。然后在各自的文件夹下放置各自的文件。\n2.4.2 搜索页面 搜索页面主要功能是提供站内搜索。PaperMod主题提供了search.html，所以我们只需要做两件事情。\n在与posts文件夹处于同级目录下，创建search.md，更改头文件内容。 +++ title = \u0026#34;Search\u0026#34; draft = false layout = \u0026#34;search\u0026#34; +++ 然后在配置文件hugo.yaml中添加该设置。 - identifier: search name: 🔍Search url: search weight: 1 identifier和name可以更改自己喜欢的内容，url后必须是search。\n补充:\n如果需要在搜索页面中显示当前时间的话，需要修改layouts/_default/search.html。将以下内容的第6行添加到自己的search.html文件中，便可以在搜索界面显示时间。\n\u0026lt;header class=\u0026#34;page-header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{- (printf \u0026#34;%s\u0026amp;nbsp;\u0026#34; .Title ) | htmlUnescape -}} ... \u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;post-date\u0026#34;\u0026gt;{{ now.Format \u0026#34;2006-01-02\u0026#34; }}\u0026lt;/p\u0026gt; 3. GitHub Pages部署 3.1 事前准备 首先需要登录自己的GitHub账号，并且分别创建两个仓库。一个仓库为私有仓库，名字自定义，我的仓库名是my_blog，另一个仓库为公开仓库，仓库名必须为username.github.io，username是你GitHub的用户名，该仓库主要是为了更新和显示博客内容。可以在创建仓库时添加readme文件，内容任意。\n公共仓库按照下图进行操作，记得后续所有都是上传到master这个branch下。 3.2 上传本地文件至GitHub私有仓库 参考通过终端上传文件至GitHub这篇文章上传文件至GitHub仓库。\n首先来到hugo的根目录（就是包含所有hugo文件的目录），然后按照下述顺序进行文件上传。\ngit init git add . git commit -m \u0026#34;comment\u0026#34; git remote rm origin git remote add origin private_repository_url git push origin master 以上操作应该会成功将所有文件上传至私有仓库。\n其中我遇到的错误以及解决方案：\n源引用规格master没有匹配。 git branch -M master 尚未暂存以备提交的变更：修改尚未加入提交（使用 \u0026ldquo;git add\u0026rdquo; 和/或 \u0026ldquo;git commit -a\u0026rdquo;）。 git add --all git commit -m \u0026#34;comment\u0026#34; git remote rm origin git remote add origin private_repository_url git push origin master 3.3 上传本地public文件至GitHub公开仓库。 首先公开仓库的名字一定要是username.github.io。\n上传的主要流程是：\n在本地hugo的根目录下创建public文件夹。 hugo -F --cleanDestinationDir 将GitHub公开仓库克隆到本hugo根目录下，并将public内所有文件和hugo.yaml（非常重要！！）添加到本地仓库。 git clone public_repository_url cp hugo.yaml username.github.io/ mv public/* username.github.io/ cd username.github.io 上传本地仓库到GitHub git add . git commit -m \u0026#34;rebuild_site $(date)\u0026#34; git push origin master 以上为初次上传时流程，之后的上传可以通过执行脚本，自动更新。 完成上述内容时，可以在本地运行hugo，并且用设置的username.github.io去尝试，如果成功则证明可行。\n设置脚本文件，方便每次更新内容。\n脚本文件可以保存在hugo的根目录下，名字随意，我的名字是issue.sh。 hugo -F --cleanDestinationDir cp hugo.yaml public/ rm -rf username.github.io/* mv public/* username.github.io/ rm -rf public cd username.github.io/ git add . git commit -m \u0026#34;rebuild_site $(date)\u0026#34; git push -u origin +master 上述所有的username.github.io都需要换成自己的公开仓库名。 ssh文件的执行如下。\n./issue.sh 如果以上的内容顺利完成，接下来就可以进行GitHub Actions的部署。\n3.4 GitHub Actions部署 本次部署主要是让静态博客可以被其他人访问到，部署在GitHub网站中完成。\n生成token\n首先需要设置一个密钥，去到个人主页的Settings,然后找到左边最下面的Developer Settings，然后按照下述页面所示操作。 点击generate token创建key，并且记住以ghp_开头的token。\n添加token\n接下来将刚刚得到的token，添加到下图位置，名字可以为MY_BLOG。 添加workflows\n首先一定要确保当前branch为master。\n然后按下图顺序执行，最终会生成一个hugo.yml文件。 hugo.yml文件内容参考如下：\nname: pages-auto-build-deploy on: # workflow_dispatch: push: branches: - main jobs: build-and-deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.130.0\u0026#39; #需要更改，结合自己的hugo版本进行更改 ，利用命令hugo version可查看。 extended: true #根据hugo version查询结果判断。 - name: Build Hugo run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: GitHub_token: ${{ secrets.MY_BLOG }} # MY_BLOG为刚刚添加的token名称 publish_dir: ./public commit_message: ${{ GitHub.event.head_commit.message }} 完成以上所有操作后，可以在GitHub顶端的Actions内查看workflows是否成功启动，成功启动后任何人都可以直接利用username.github.io访问你的博客。\n4. 评论区功能实现 4.1 实现过程 直接参考Vercel 部署，非常详细，几乎没有任何问题。也可以参考该视频Twikoo Vercel 部署教程。\nMangoDB账号申请 数据库区域选择部分\n如果你在境外，选择离自己近的地区也可以，如果在境内还是建议按照推荐区域进行设置。 MangoDB连接字符串 需要记住自己设置的passward最后一步只需要复制MangoDB连接字符串既可，先不需要做更改。 Vercel账号申请\n这个地方需要注意的是，在申请页面需要登录自己的GitHub账号，并且创建一个新的仓库，名字任意。完成该步骤之后，再按照链接内容进行操作。 其他部分只要按照链接流程来，应该是不会有问题的。需要注意的是，在完成部署之后，你的vercel页面应该像下图所示，在其中需要记住红圈处的版本号。\n4.2 调整本地文件 修改comments.html文件\n文件目录在/layouts/partials/comments.html，文件内应该是空，所以直接添加以下代码。 \u0026lt;!-- Twikoo --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;pagination__title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;pagination__title-h\u0026#34; style=\u0026#34;font-size: 20px;\u0026#34;\u0026gt;Comments\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;tcomment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/twikoo/{{ .Site.Params.twikoo.version }}/twikoo.all.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; twikoo.init({ envId: \u0026#34;https://******/\u0026#34;, //这里填写自己的envId el: \u0026#34;#tcomment\u0026#34;, lang: \u0026#39;en-US\u0026#39;, //zh_CN path: window.TWIKOO_MAGIC_PATH||window.location.pathname, }); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 修改single.html文件 文件目录在/layouts/_default/single.html，将下述三行代码添加到\u0026lt;article\u0026gt;内部的最后即可。 \u0026lt;article class=\u0026#34;post-single\u0026#34;\u0026gt; ... {{- if (.Param \u0026#34;comments\u0026#34;) }} {{- partial \u0026#34;comments.html\u0026#34; . }} {{- end }} \u0026lt;/article\u0026gt; 修改配置文件hugo.yaml\n在params内，添加twikoo的版本号，也就是vercel页面中的版本号，代码如下图所示。 params: twikoo: version: 1.6.39 完成以上步骤，便可以在自己的文章下看到评论区，并可以进行相关设置。\n参考链接 本人愚笨，参考了很多大神的博客和文章，才完成了自己博客的基本内容。很多补充内容可以参考以下链接。\nhugo博客搭建 | PaperMod主题 Hugo + PaperMod搭建技术博客 将hugo博客部署到github Hugo+Github Pages+Github Action博客方案之三——配置Github Action实现自动发布 ","permalink":"https://garywy.github.io/zh/posts/tech/hugo+github-pages%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"1. 前言 原本是因为学习任务要求需要做一个Web Service，结果阴差阳错的发现了hugo这个工具。所以借此机会利用hugo制作了自己的个人博","title":"Hugo+GitHubpages建立个人博客"},{"content":"姓名: Gary 性别: 男性 邮箱: gary510wyl@gmail.com 职业: 学生 ","permalink":"https://garywy.github.io/zh/about/","summary":"姓名: Gary 性别: 男性 邮箱: gary510wyl@gmail.com 职业: 学生","title":"关于"}]